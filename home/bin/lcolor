#!/bin/bash

print_usage() {
    cat <<_END_
Highlights lines of the input based on different occurrances of a pattern.

Usage: $0 -h
       $0 [options] [file1 file2 ...]

Options:
    -h        This help message.
    -i        Case insensitive pattern.
    -p regex  The pattern to search for.
    -r        Interpret the pattern as extended regular expression.
_END_
}

cleanup() {
    if [ -n "$tmpdir" ]; then
        rm -rf "$tmpdir"
    fi
}

interrupted() {
    cleanup
    exit 128
}

# -------- Main body --------

colors=(Red Green Yellow Blue Purple Cyan White IRed IGreen IYellow IBlue IPurple ICyan IWhite)

flags=
sedargs=
hlargs=
pattern=
parprefix='\'
while getopts ":hip:r" Option; do
    case $Option in
    h)
	    print_usage
	    exit
	    ;;
	i)
	    flags+=I
        hlargs+="-i"
	    ;;
    p)
        pattern="$OPTARG"
        ;;
	r)
        sedargs+="-r"
        hlargs+="-r"
	    parprefix=
	    ;;
    esac
done

shift $(($OPTIND - 1))

if [ -z "$pattern" ]; then
    echo "Pattern is not given."
    exit 1
fi

openpar="$parprefix("
closepar="$parprefix)"
match="^.*${openpar}${pattern}${closepar}.*$"

tmpdir=$(mktemp -d -t lcolor.XXXXXXXX)

trap interrupted SIGTERM
trap interrupted SIGINT
trap interrupted SIGHUP

pipe="$tmpdir/pipe.0"
mkfifo "$pipe"
cat "$@" >"$pipe" &
i=0

while read line; do
    color_index=$((i % ${#colors[@]}))
    ((++i))
    prevpipe="$pipe"
    pipe="$tmpdir/pipe.$i"
    color="${colors[color_index]}"
    mkfifo "$pipe"
    hl -l "$color" $hlargs "$line" <"$prevpipe" >"$pipe" &
done < <(cat "$@" | sed $sedargs -n "s/${match}/\\1/${flags}p" | sort | uniq)

cat "$pipe"

wait
result=$?
cleanup
exit $result

